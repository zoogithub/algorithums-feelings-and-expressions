首先考虑串的类型
1.完全重复的串：
aaaaaaaa……
2.完全不重复的串“
abcdefg……
3.部分重复，部分不重复的串
abcdeaaaaabcde……



对于1，要找到完全相等的串，
如
短串：
a【7】=aaaaaaa
长串
b【】=aaaaaabaaacaaaaaaaacdegh……
匹配到第七个字符时（b【6】），匹配失败
这时候，前面六个无论怎么样都不可能得到长度一样的子串
因此，直接+7，从b【7】开始搜索（这里跳过了b）
b[10]再次失败，这时候，直接+4，从b【11】开始
因此，我们可以总结出一个规律，当搜索的偏移量到i时失败，那么下一次失败时，直接从数组的【x+i】开始搜索，也就是跳过了i个数

对于2，
如
短串：
a【7】=abcdefg
b【】=abcdefabcabcdefg
匹配到第七个字符时，匹配失败
这时候，同上面一样，前面六个无论怎么样都不可能得到长度一样的子串
但是，如果和上面一样从b【7】开始搜索，我们会发现a被跳过了，可能会出现匹配错误的问题
为什么会这样呢？
对于完全一样的串，我们可以保证，只要当前的数不匹配当前位置的值，那么它也不会匹配所有位置的值，而对于完全不一样的串，我们发现，哪怕当前的数不符合当前位置的值，它也可能符合第一个数的值
所以，我们只能从b【6】开始搜索
搜索到b【9】失败，那么就从b【9】开始搜索


那么，对于情况3，是否仍然适用1和2的结论呢？

思路1：直接按照2的情况，无论是什么样的串，都少跳一步？

思路2：我们可不可以首先分析需要匹配的短串，有几个重复，几个不重复？
将短串看成许多个更短的串，它们有的完全是情况1，有的完全是情况2，再分析到底何种串需要什么样的策略？
最小的情况1是：aa
最小的情况2是：ab
那么，我们看看它们的组合会有什么反应：

例1：
短串：aab
长串：aaabaab
这里本来到b【2】不匹配，按照情况1应为+3，按照情况2应为+2
然而，事实上只能+1，与1，2都不符合
为什么会这样呢？
我们回到情况1
情况1之所以能直接跳过，是因为我们和短串后面的数据进行了比较，串本身包含的信息里面就明确了字母只能是同一个字母，所以前面的全部都不用看了，可以pass掉
而对于情况2
我们之所以能直接跳过，是因为我们可以保证，当前的数字最多只能与长串中的其中一个字母匹配，那么我们就只需要确定第一个匹配与否的问题

那么，现在对于3
我们没有办法确定，数字是否只能与其中一个字符匹配成功，可能对于长串的其中一个不匹配，而和其他都匹配

我们从短串中可以提取出：最大连续重复长度，最大连续不重复长度，

如果前面是重复的，而后一位的字符刚好与前面不一致（aaaab），那么，当数字在这一位（b）匹配失败时，还是只能移一位
aababa
abaaba
如果前面是重复的，后面的字符也是重复的，只有中间不一样


如果前面是不重复的，那么，又回到了情况2和情况1之间做选择

选择的依据在于：
最后一位是否和第一位一致，如是，则进入2，否，则进入1


这种思路到这里，只能靠进一步的穷举来确定下一步的方案，但是，这么多的字符序列，继续穷举下去时间花费太长，似乎是进入到一个错误的方法里面了。或许这样能最终得到答案，但是我们是不是可以有更简单的思路？

（注：出现这个想法之后的第二天，我们发现，短串和长串如果能在前面匹配，那么必然保证了前面一部分是相等的，而只有最后一个字符不相等，那么，我们如果要研究匹配，只需要研究短串就行了（顶多在最后一位不同）
）

前面，我们的思路通过从数据入手，从一组极端数据出发，渐渐逼近真实情况，发现越来越难得到答案。
那么，我们可以换一个想法，从方法入手，去解决这个问题
我们不管数据是什么，首先我们想象，两个短棒，滑动一段距离的时候，是如何运行的
我们只需要确定滑入和滑出的两端，就可以得到偏移量，那么，对于字符串，我们能不能只确定两端的位置，就可以得到答案呢？
这时候，似乎陷入了瓶颈
由于从数据入手时得到了“只需要研究短串“的结果，我们进一步发现，这两个小棒，是由两个前面完全对称，只有最后一位不相同的串组成的，那么，这个问题就简化成了：对于两个对称串之间的研究
由于对称性，我们只研究一个简单串就可以了
那么从长度为3开始，有四种情况：

aaa、abc 、aba、aab，abb
它们分别代表：完全相同、完全不同，以及部分相同的两种情况
对于aaa，无论怎么滑，必至少有一个字符相等
对于abc，无论怎么滑，只有互相对应的时候才可以，否则必不可能相等
对于aba，在最左端和最右端有一个匹配点
对于aab，在第一，第二处有一个匹配点
对于abb，在二、三处有一个匹配点
由于我们进行匹配的时候，已经选定了一个方向，因此4和5只能二选一保留一种情况
因为按照习惯，我们一直是从左边开始匹配的，因此只选择情况4

对于特别长的字符串
比如aba？？？
在第六位匹配失败了也只能滑到第一位，除非后面三位也有类似规律
那么，似乎这个问题就解决了
剩下的细节问题就是：最后一位匹配失败的，会不会对结果产生影响呢？
从最开始的唯一和绝对重复，我们发现，似乎有一定影响，但这些都是比较容易解决的，这里不再赘述



以下是kmp设计者的思路
将最左端和最右端是否有“最长重复序列”
比如abcab
左边有ab，右边有ab，那它就是一个“最长重复序列”，和本人最终思路基本相近


#更新：
许久后重新看到这篇文章，还能感觉到当时的绝望
写这篇文章的过程，是对局部与整体关系认识逐步加深的过程
从这篇文章开始，才真正认识到，一条腿走路是不可能成功的
问题的关键在于构造，如果不懂得构造对称关系，一个一个重复尝试的话，只会花费大量的时间。重局部而轻整体的结果，就是大部分力气白白浪费
类别现实生活中的棍型物体，质量对称/大型机械齿轮咬合其实可以很快得到答案
算法很简单，但正是从这篇文章开始，思考方式才真正得到改变
整体和局部缺一不可


